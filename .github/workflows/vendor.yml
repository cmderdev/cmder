name: Update Vendor

on:
  workflow_dispatch:
  schedule:
  # At 13:37 UTC every day.
  - cron: '37 13 * * *'

defaults:
  run:
    shell: pwsh

permissions:
  contents: read

jobs:
  vendor:

    runs-on: windows-latest
    continue-on-error: false
    timeout-minutes: 15
    permissions:
      contents: write
      pull-requests: write

    steps:
    - uses: actions/checkout@v6
      with:
        fetch-depth: 0

    - name: Summary - Workflow started
      shell: pwsh
      run: |
        echo "## üì¶ Vendor Update - Workflow Summary" >> $env:GITHUB_STEP_SUMMARY
        echo "" >> $env:GITHUB_STEP_SUMMARY
        echo "üîç Checking for vendor dependency updates..." >> $env:GITHUB_STEP_SUMMARY
        echo "" >> $env:GITHUB_STEP_SUMMARY

    - id: make-changes
      name: Checking for updates
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
          $currentVersion = (Get-Content .\vendor\sources.json | ConvertFrom-Json)
          . .\scripts\update.ps1 -verbose
          Set-GHVariable -Name COUNT_UPDATED -Value $count
          $newVersion = (Get-Content .\vendor\sources.json | ConvertFrom-Json)
          $listUpdated = ""
          $updateMessage = "| Name | Old Version | New Version |`n| :--- | :---: | :---: |`n"
          $majorUpdates = @()
          $singleDepName = ""
          $singleDepOldVersion = ""
          $singleDepNewVersion = ""
          foreach ($s in $newVersion) {
            $oldVersion = ($currentVersion | Where-Object {$_.name -eq $s.name}).version
            if ($s.version -ne $oldVersion) {
              $repoUrl = ($repoUrl = $s.Url.Replace("/archive/", "/releases/")).Substring(0, $repoUrl.IndexOf("/releases/")) + "/releases"

              # Store single dependency info for messages (only if this is the only update)
              if ($count -eq 1) {
                $singleDepName = $s.name
                $singleDepOldVersion = $oldVersion
                $singleDepNewVersion = $s.version
              }

              # Determine change type and emoji
              $changeType = "unknown"
              $emoji = "üîÑ"
              $isMajor = $false
              try {
                # Handle versions with more than 4 parts
                $oldVerStr = $oldVersion.Split('-')[0]
                $newVerStr = $s.version.Split('-')[0]

                # Split by dots and take only numeric parts, first 4 max
                $oldParts = $oldVerStr.Split('.') | Where-Object { $_ -match '^\d+$' } | Select-Object -First 4
                $newParts = $newVerStr.Split('.') | Where-Object { $_ -match '^\d+$' } | Select-Object -First 4

                # Ensure we have at least 2 parts (major.minor)
                if ($oldParts.Count -ge 2 -and $newParts.Count -ge 2) {
                  $oldVerParseable = $oldParts -join '.'
                  $newVerParseable = $newParts -join '.'

                  $oldVer = [System.Version]::Parse($oldVerParseable)
                  $newVer = [System.Version]::Parse($newVerParseable)

                  if ($newVer.Major -gt $oldVer.Major) {
                    $changeType = "major"
                    $emoji = "üî•"
                    $isMajor = $true
                  } elseif ($newVer.Minor -gt $oldVer.Minor) {
                    $changeType = "minor"
                    $emoji = "üöÄ"
                  } else {
                    $changeType = "patch"
                    $emoji = "‚¨ÜÔ∏è"
                  }
                }
              } catch {
                $changeType = "unknown"
                $emoji = "üîÑ"
              }

              # Track major updates for changelog section
              if ($isMajor) {
                $compareUrl = "$repoUrl/compare/v$oldVersion...v$($s.version)"
                $majorUpdates += @{
                  name = $s.name
                  oldVersion = $oldVersion
                  newVersion = $s.version
                  compareUrl = $compareUrl
                  repoUrl = $repoUrl
                }
              }

              $listUpdated += "$($s.name) v$($s.version), "
              $updateMessage += "| $emoji **[$($s.name)]($repoUrl)** | \`$oldVersion\` | **\`$($s.version)\`** |`n"
            }
          }
          if ($count -eq 0) { return }
          Set-GHVariable -Name LIST_UPDATED -Value $listUpdated.Trim(', ')
          # Set single dependency variables (they will only be used if COUNT_UPDATED is 1)
          # Use safe fallback values in case variables weren't set (shouldn't happen but prevents errors)
          if ([string]::IsNullOrEmpty($singleDepName) -and $count -eq 1) {
            # This shouldn't happen, but if it does, log a warning
            Write-Warning "Single dependency name not set despite count being 1"
            $singleDepName = "unknown-package"
            $singleDepOldVersion = "unknown"
            $singleDepNewVersion = "unknown"
          } elseif ([string]::IsNullOrEmpty($singleDepName)) {
            # For multiple dependencies, set placeholder values (won't be used)
            $singleDepName = ""
            $singleDepOldVersion = ""
            $singleDepNewVersion = ""
          }
          Set-GHVariable -Name SINGLE_DEP_NAME -Value $singleDepName
          Set-GHVariable -Name SINGLE_DEP_OLD_VERSION -Value $singleDepOldVersion
          Set-GHVariable -Name SINGLE_DEP_NEW_VERSION -Value $singleDepNewVersion
          echo "UPDATE_MESSAGE<<<EOF`n$updateMessage`n<EOF" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8

          # Generate major updates changelog section
          if ($majorUpdates.Count -gt 0) {
            $changelogSection = "`n<details>`n<summary>üî• Major version updates - View changelog</summary>`n`n"
            foreach ($update in $majorUpdates) {
              $changelogSection += "### [$($update.name)]($($update.repoUrl))`n"
              $changelogSection += "**$($update.oldVersion)** ‚Üí **$($update.newVersion)**`n`n"
              $changelogSection += "- [View full changelog]($($update.compareUrl))`n"
              $changelogSection += "- [Release notes]($($update.repoUrl)/tag/v$($update.newVersion))`n`n"
            }
            $changelogSection += "</details>`n"
            echo "CHANGELOG_SECTION<<<EOF`n$changelogSection`n<EOF" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
          } else {
            echo "CHANGELOG_SECTION=" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
          }

    - name: Summary - Update check results
      shell: pwsh
      run: |
        $count = $env:COUNT_UPDATED
        if ($count -eq 0) {
          echo "### ‚úÖ No Updates Available" >> $env:GITHUB_STEP_SUMMARY
          echo "" >> $env:GITHUB_STEP_SUMMARY
          echo "All vendor dependencies are up to date! üéâ" >> $env:GITHUB_STEP_SUMMARY
        } else {
          $word = if ($count -eq 1) { 'dependency' } else { 'dependencies' }
          echo "### üîÑ Updates Found" >> $env:GITHUB_STEP_SUMMARY
          echo "" >> $env:GITHUB_STEP_SUMMARY
          if ($count -eq 1) {
            echo "üì¶ **$env:SINGLE_DEP_NAME** updated from \`$env:SINGLE_DEP_OLD_VERSION\` to \`$env:SINGLE_DEP_NEW_VERSION\`" >> $env:GITHUB_STEP_SUMMARY
          } else {
            echo "üì¶ **$count** vendor $word updated:" >> $env:GITHUB_STEP_SUMMARY
          }
          echo "" >> $env:GITHUB_STEP_SUMMARY
          echo "$env:UPDATE_MESSAGE" >> $env:GITHUB_STEP_SUMMARY
          echo "" >> $env:GITHUB_STEP_SUMMARY

          # Check if we can auto-merge (only minor/patch changes)
          $hasBreaking = $env:HAS_BREAKING_CHANGES -eq 'True'
          if ($hasBreaking) {
            echo "> ‚ö†Ô∏è **Note:** This update contains major version changes that may include breaking changes." >> $env:GITHUB_STEP_SUMMARY
          } else {
            echo "> ‚ÑπÔ∏è **Note:** This update only contains minor or patch changes." >> $env:GITHUB_STEP_SUMMARY
          }
        }

    - name: Auto-merge minor updates
      if: env.COUNT_UPDATED > 0 && env.HAS_BREAKING_CHANGES != 'True'
      shell: pwsh
      run: |
        try {
          echo "### üöÄ Auto-merging Updates" >> $env:GITHUB_STEP_SUMMARY
          echo "" >> $env:GITHUB_STEP_SUMMARY
          echo "Attempting to automatically merge non-breaking changes to master..." >> $env:GITHUB_STEP_SUMMARY

          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

          # Commit the changes
          git add vendor/sources.json
          $commitResult = git commit -m "‚¨ÜÔ∏è Update dependencies ($env:LIST_UPDATED)"

          # Push directly to master
          git push origin HEAD:master

          echo "" >> $env:GITHUB_STEP_SUMMARY
          echo "‚úÖ **Success!** Updates have been automatically merged to master." >> $env:GITHUB_STEP_SUMMARY
          echo "" >> $env:GITHUB_STEP_SUMMARY
          echo "**Updated dependencies:** $env:LIST_UPDATED" >> $env:GITHUB_STEP_SUMMARY

          # Set a flag to skip PR creation
          echo "AUTO_MERGED=true" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
        } catch {
          echo "" >> $env:GITHUB_STEP_SUMMARY
          echo "‚ö†Ô∏è **Warning:** Unable to automatically merge updates." >> $env:GITHUB_STEP_SUMMARY
          echo "" >> $env:GITHUB_STEP_SUMMARY
          echo "**Error:** $($_.Exception.Message)" >> $env:GITHUB_STEP_SUMMARY
          echo "" >> $env:GITHUB_STEP_SUMMARY
          echo "Falling back to creating a pull request..." >> $env:GITHUB_STEP_SUMMARY

          Write-Warning "Failed to auto-merge: $($_.Exception.Message)"

          # Reset the commit if one was made
          if ($commitResult) {
            git reset --hard HEAD~1
          }

          # Set flag to create PR instead
          echo "AUTO_MERGED=false" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
        }

    - uses: peter-evans/create-pull-request@v8
      if: env.COUNT_UPDATED > 0 && (env.HAS_BREAKING_CHANGES == 'True' || env.AUTO_MERGED == 'false')
      with:
        title: ${{ env.COUNT_UPDATED == '1' && format('‚¨ÜÔ∏è Update {0}', env.LIST_UPDATED) || format('‚¨ÜÔ∏è Update {0} vendored dependencies', env.COUNT_UPDATED) }}
        body: |
          ### ${{ env.COUNT_UPDATED == 1 && format('üì¶ Updated {0} from `{1}` to `{2}`', env.SINGLE_DEP_NAME, env.SINGLE_DEP_OLD_VERSION, env.SINGLE_DEP_NEW_VERSION) || format('üì¶ Automatically updated {0} dependencies', env.COUNT_UPDATED) }}

          ${{ env.UPDATE_MESSAGE }}

          ${{ env.CHANGELOG_SECTION }}

          ---

          ${{ env.HAS_BREAKING_CHANGES == 'True' && '‚ö†Ô∏è **This update contains major version changes that may include breaking changes.**' || '‚ÑπÔ∏è This update only contains minor or patch changes.' }}

          Please verify and then **Merge** the pull request to apply the updates.
        commit-message: '‚¨ÜÔ∏è Update dependencies (${{ env.LIST_UPDATED }})'
        branch: update-vendor
        base: master

    - name: Summary - Pull request created
      if: env.COUNT_UPDATED > 0 && (env.HAS_BREAKING_CHANGES == 'True' || env.AUTO_MERGED == 'false')
      shell: pwsh
      run: |
        echo "### üéâ Pull Request Created" >> $env:GITHUB_STEP_SUMMARY
        echo "" >> $env:GITHUB_STEP_SUMMARY
        echo "A pull request has been created to update the vendor dependencies." >> $env:GITHUB_STEP_SUMMARY
        echo "" >> $env:GITHUB_STEP_SUMMARY
        echo "**Branch:** \`update-vendor\`" >> $env:GITHUB_STEP_SUMMARY
        echo "" >> $env:GITHUB_STEP_SUMMARY
        echo "**Updated dependencies:** $env:LIST_UPDATED" >> $env:GITHUB_STEP_SUMMARY
        echo "" >> $env:GITHUB_STEP_SUMMARY
        if ($env:HAS_BREAKING_CHANGES -eq 'True') {
          echo "> ‚ö†Ô∏è **Manual review required:** This update contains major version changes." >> $env:GITHUB_STEP_SUMMARY
        } else {
          echo "> ‚ÑπÔ∏è **Note:** Auto-merge failed, manual review required." >> $env:GITHUB_STEP_SUMMARY
        }
        echo "" >> $env:GITHUB_STEP_SUMMARY
        echo "Please review and merge the pull request to apply the updates." >> $env:GITHUB_STEP_SUMMARY
